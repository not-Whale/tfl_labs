## Лабораторная работа 1 (обнуление)
### Задача
Реализовать проверку пользовательской оценки TRS в полиномах.

### Подсказки 
1. Из файла читается TRS, в которой все функции одноместны, и их интерпретация как полиномов. У полиномов могут быть и отрицательные коэффициенты (кроме старшего).
2. Всякое правило имеет вид $f_1 (f_2 (. . . f_n (x))) → g_1 (g_2 . . . g_m (x))$. Чтобы гарантировать его завершаемость, нужно убедиться, что его левая часть растёт быстрее, чем правая, в заданной интерпретации. То есть необходимо проверить, является ли положительной на бесконечности функция $f_1 ◦ f_2 ◦ . . . f_n − g_1 ◦ g_2 ◦ . . . g_m$.
3. Если это условие выполняется для всех правил TRS, то нужно сообщить о завершаемости TRS. Иначе вывести сообщение, на каких правилах переписывания нарушается убывание.

### Идея
1. Распарсить данные и организовать удобный способ их хранения. Правило хранится в виде пары: текстовое представление и двунаправленный список (deque), элементы которого являются объектами класса функции. Класс функции хранит в себе сигнатуру (местность каждой функции == 1 по заданию) и соответствующую полиномиальную оценку в строковом и функциональном представлении.
2. Перебрать все данные на вход правила, проверить каждое из них на завершаемость прямым сравнением левых и правых частей значениями на бесконечности (либо попробовать найти более умное решение сравнение полиномов).
3. В процессе перебора сохранять результаты вычислений: OK - если завершаемость выполняется, текстовое представление правила переписывания.
4. Вывод результатов работы.
5. Небольшой гайд и условное обозначение выходных данных.


### Сложности
1. Написание парсеров для входных данных (решение: копипаста и доработка, если найдется что-то похожее).
2. Перевод полинома из строкового представления в набор функций (решение: поиск соотвествующих парсеров и грамматик разбора полиномов, после чего рукописное сопоставление и доработка).
3. Сравнение двух полиномов на бесконечности (решение: погуглить и ввести необходимый уровень приближения и абстракции).
4. Нагруженность алгоритма "в лоб" (решение: ???).

### Синтаксис входных данных
TRS BNF если местность любая:
```
rule ::= term '=' term
term ::= 'x' | constructor '(' termrec term ')'
termrec ::= term ',' termrec | ε
constructor ::= [a-z]
```

TRS BNF с конструкторами местности 1:
```
rule ::= term '=' term
term ::= 'x' | constructor '(' term ')'
constructor ::= [a-z]
```

Полиномиальная оценка:
```
interpretation ::= constructor '->' polynomial
polynomial ::= monomial | monomial (+ | -) polymonial
polynomial ::= monomial | monomial '+' polynomial | monomial '-' polynomial
monomial ::= '-'? (number '*')? 'x' ('^' number)?
# введем условность, что x == x^1 для удобства вычислений
monomial ::= 'x' | 'x' '^' number | number '*' 'x' | number '*' 'x' '^' number | '-' 'x' | '-' 'x' '^' number | '-' number '*' 'x' | '-' number '*' 'x' '^' number
number ::= [1-9][0-9]*
```